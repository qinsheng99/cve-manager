package main

import (
	"net/http"
	"os"
	"strings"

	"github.com/sirupsen/logrus"
	"gopkg.in/yaml.v3"

	"github.com/opensourceways/cve-manager/cve/domain"
	"github.com/opensourceways/cve-manager/cve/domain/dp"
	"github.com/opensourceways/cve-manager/cve/domain/repository"
	"github.com/opensourceways/cve-manager/utils"
)

type pkgBasic struct {
	Org         string    `json:"org"`
	Platform    string    `json:"platform"`
	Community   string    `json:"community"`
	PackageInfo []pkgInfo `json:"package_info"`
}

type pkgInfo struct {
	Repo        string   `json:"repo"`
	Version     string   `json:"version"`
	Assigne     string   `json:"assigne"`
	RepoDesc    string   `json:"repo_desc"`
	Milestone   string   `json:"milestone"`
	PackageName string   `json:"package_name"`
	Branch      []string `json:"branch"`
}

func (p *pkgBasic) toApplicationPkgCmd() (v domain.ApplicationPackage, err error) {
	v.Repository.Org = p.Org
	v.Repository.Repo = p.PackageInfo[0].Repo
	v.Repository.Platform = p.Platform
	v.Repository.Desc = dp.NewDescription("")
	if v.Repository.Community, err = dp.NewCommunity(p.Community); err != nil {
		return
	}

	v.Packages = make([]domain.Package, len(p.PackageInfo))

	for i := range p.PackageInfo {
		var pakg = domain.Package{
			Version:   p.PackageInfo[i].Version,
			Milestone: p.PackageInfo[i].Milestone,
		}

		if pakg.Name, err = dp.NewPackageName(p.PackageInfo[i].PackageName); err != nil {
			return
		}

		if p.PackageInfo[i].Assigne != "" {
			if pakg.Assignee, err = dp.NewAccount(p.PackageInfo[i].Assigne); err != nil {
				return
			}
		}

		v.Packages[i] = pakg
	}

	return
}

func (p *pkgBasic) toBasePkgCmd() (v []domain.BasePackage, err error) {
	for _, info := range p.PackageInfo {
		b := domain.BasePackage{
			Repository: domain.PackageRepository{
				Org:      p.Org,
				Repo:     info.Repo,
				Platform: p.Platform,
				Desc:     dp.NewDescription(info.RepoDesc),
			},
		}

		if b.Name, err = dp.NewPackageName(info.PackageName); err != nil {
			return
		}

		if b.Repository.Community, err = dp.NewCommunity(p.Community); err != nil {
			return
		}

		for _, branch := range info.Branch {
			b.Branches = append(b.Branches, domain.BasePackageBranch{UpstreamVersion: info.Version, Branch: branch})
		}

		v = append(v, b)
	}

	return
}

func (t *task) ApplicationPkg() {
	for _, v := range t.cfg.Pkg.Application {
		if err := t.applicationPkg(v); err != nil {
			logrus.Errorf("application pkg failed, community:%s, err:%s", v.Community, err.Error())
		} else {
			community, _ := dp.NewCommunity(v.Community)
			if err = t.application.DeleteApplicationPkgs(repository.OptToDeleteApplicationPkgs{
				UpdatedAt: utils.Date(),
				Community: community,
			}); err != nil {
				logrus.Errorf("delete application pkg failed, community:%s, err:%s", v.Community, err.Error())
			}
		}
	}
}

func (t *task) BasePkg() {
	for _, v := range t.cfg.Pkg.Base {
		if err := t.basePkg(v); err != nil {
			logrus.Errorf("base pkg failed, err:%s", err.Error())
		} else {
			community, _ := dp.NewCommunity(v.Community)
			if err = t.base.DeleteBasePkgs(repository.OptToDeleteApplicationPkgs{
				UpdatedAt: utils.Date(),
				Community: community,
			}); err != nil {
				logrus.Errorf("delete base pkg failed, err:%s", err.Error())
			}
		}
	}
}

func (t *task) applicationPkg(c communityConfig) error {
	var appPkgs []domain.ApplicationPackage
	for i := range c.Url {
		req, err := http.NewRequest(http.MethodGet, c.Url[i], nil)
		if err != nil {
			return err
		}
		v, _, err := t.cli.Download(req)
		if err != nil {
			return err
		}

		_ = os.Remove(c.DownloadFile)
		if err = os.WriteFile(c.DownloadFile, v, os.ModePerm); err != nil {
			return err
		}

		var res = make(map[string]map[string]map[string]string)
		if v, err = os.ReadFile(c.DownloadFile); err == nil {
			if c.Community == "opengauss" {
				var gauss map[string]map[string]string
				err = yaml.Unmarshal(v, &gauss)
				res[c.DefaultRepo] = gauss
			} else {
				err = yaml.Unmarshal(v, &res)
			}
		}

		if err != nil {
			return err
		}

		var resp = pkgBasic{
			Org:         c.Org,
			Platform:    c.Platform,
			Community:   c.Community,
			PackageInfo: applicationPkgInfo(res),
		}

		cmd, err := resp.toApplicationPkgCmd()
		if err != nil {
			return err
		}

		appPkgs = append(appPkgs, cmd)
	}

	for i := range appPkgs {
		for k := range appPkgs[i].Packages {
			v := appPkgs[i].Packages[k]
			repo := appPkgs[i].Repository
			appPkg, err := t.application.FindApplicationPkg(
				repository.OptToFindApplicationPkg{
					Name:      v.Name,
					Version:   v.Version,
					Repo:      repo.Repo,
					Community: repo.Community,
				},
			)
			data := domain.ApplicationPackage{
				Packages:   []domain.Package{v},
				Repository: repo,
			}
			if err == nil {
				data.Packages[0].Id = appPkg.Packages[0].Id
				if err = t.application.SaveApplicationPkg(&data); err != nil {
					logrus.Errorf("save pkg failed, err:%s\n", err.Error())

					return err
				}
			} else {
				if err = t.application.AddApplicationPkg(&data); err != nil {
					logrus.Errorf("add pkg failed, err:%s\n", err.Error())
				}
			}
		}
	}

	return nil
}

func (t *task) basePkg(c communityConfig) error {
	var resp = pkgBasic{Community: c.Community, Platform: c.Platform, Org: c.Org}
	for i := range c.Url {
		var res map[string]interface{}
		req, err := http.NewRequest(http.MethodGet, c.Url[i], nil)
		if err != nil {
			return err
		}
		if _, err = t.cli.ForwardTo(req, &res); err != nil {
			return err
		}

		if res["data"] != nil {
			resp.PackageInfo = append(resp.PackageInfo, basePkgInfo(res["data"].([]interface{}))...)
		}
	}

	basePkg, err := resp.toBasePkgCmd()
	if err != nil {
		return err
	}

	for i := range basePkg {
		basepkg := &basePkg[i]
		v, err := t.base.FindBasePkg(repository.OptToFindBasePkg{
			Community: basepkg.Repository.Community,
			Name:      basepkg.Name,
		})
		if err != nil {
			if err = t.base.AddBasePkg(basepkg); err != nil {
				logrus.Errorf("add base pkg failed, err:%s", err.Error())
			}
		} else {
			basepkg.Id = v.Id
			if err = t.base.SaveBasePkg(basepkg); err != nil {
				logrus.Errorf("save base pkg failed, err:%s", err.Error())

				return err
			}
		}
	}

	return nil
}

func applicationPkgInfo(res map[string]map[string]map[string]string) (data []pkgInfo) {
	for RepoKey, RepoValue := range res {
		for k, v := range RepoValue {
			data = append(data, pkgInfo{
				Repo:        RepoKey,
				Version:     v["version"],
				Assigne:     v["handler"],
				Milestone:   v["milestone"],
				PackageName: k,
			})
		}
	}

	return
}

func basePkgInfo(res []interface{}) (pkginfo []pkgInfo) {
	for i := range res {
		pkgMap := res[i]
		for repKey, repValue := range pkgMap.(map[string]interface{}) {
			var data = make(map[string]pkgInfo)
			if v, ok := repValue.(map[string]interface{})["branch_detail"]; ok {
				branchs := branchMap(v.([]interface{}))
				for _, detail := range v.([]interface{}) {
					pkgv := detail.(map[string]interface{})
					var info = pkgInfo{Repo: repKey, PackageName: repKey}
					if ver, ok := pkgv["version"].(string); ok {
						if len(ver) == 0 {
							continue
						}
						info.Branch = strings.Split(branchs[ver], ",")
						info.Version = ver
					}

					if desc, ok := pkgv["description"].([]interface{}); ok && len(desc) > 0 {
						info.RepoDesc = desc[0].(string)
					}

					if _, ok = data[info.Version]; !ok {
						data[info.Version] = info
					}
				}

				for _, info := range data {
					pkginfo = append(pkginfo, info)
				}
			}
		}
	}

	return
}

func branchMap(v []interface{}) map[string]string {
	var branchs = make(map[string]string)
	for _, i := range v {
		pkgv := i.(map[string]interface{})
		if ver, ok := pkgv["version"].(string); ok && len(ver) > 0 {
			if br, ok := pkgv["brname"].(string); ok && len(br) > 0 {
				if b, ok := branchs[ver]; ok {
					branchs[ver] = b + "," + br
				} else {
					branchs[ver] = br
				}
			}
		}
	}

	return branchs
}
