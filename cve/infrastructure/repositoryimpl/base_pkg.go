package repositoryimpl

import (
	"github.com/google/uuid"

	"github.com/opensourceways/cve-manager/common/infrastructure/postgres"
	"github.com/opensourceways/cve-manager/cve/domain"
	"github.com/opensourceways/cve-manager/cve/domain/repository"
)

type basePkgImpl struct {
	db dbimpl
}

func NewBasePkg(cfg *Config) repository.BasePkgRepository {
	return basePkgImpl{
		db: postgres.NewDBTable(cfg.Table.BasePkg),
	}
}

func (b basePkgImpl) AddBasePkg(app *domain.BasePackage) error {
	var do basePkgDO
	b.toBasePkgDO(app, &do)

	return b.db.Insert(&do)
}

func (b basePkgImpl) FindBasePkgs(opts repository.OptFindBasePkgs) (v []domain.BasePackage, err error) {
	var do []basePkgDO
	var filter []postgres.ColumnFilter

	if opts.Community != nil {
		filter = append(filter, postgres.NewEqualFilter(community, opts.Community.Community()))
	}

	err = b.db.GetRecords(
		filter,
		&do, postgres.Pagination{
			PageNum:      opts.PageNum,
			CountPerPage: opts.CountPerPage,
		}, nil,
	)
	if err != nil {
		return
	}

	v = make([]domain.BasePackage, len(do))

	for i := range do {
		if v[i], err = do[i].toBasePkg(); err != nil {
			return
		}
	}

	return
}

func (b basePkgImpl) FindBasePkg(opts repository.OptToFindBasePkg) (domain.BasePackage, error) {
	var do basePkgDO

	err := b.db.GetRecord(
		&basePkgDO{
			Community:   opts.Community.Community(),
			PackageName: opts.Name.PackageName(),
		},
		&do,
	)

	if err != nil {
		return domain.BasePackage{}, err
	}

	return do.toBasePkg()
}

func (b basePkgImpl) DeleteBasePkgs(updatedat string) error {
	return b.db.Delete(
		[]postgres.ColumnFilter{
			postgres.NewNotEqualFilter(updatedAt, updatedat),
		},
	)
}

func (b basePkgImpl) SaveBasePkg(app *domain.BasePackage) error {
	var do basePkgDO
	b.toBasePkgDO(app, &do)

	id, err := uuid.Parse(app.Id)
	if err != nil {
		return err
	}

	return b.db.UpdateRecord(&basePkgDO{Id: id}, do.toUpdatedMap())
}
