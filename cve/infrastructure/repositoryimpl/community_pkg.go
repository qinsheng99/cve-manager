package repositoryimpl

import (
	"github.com/google/uuid"

	"github.com/opensourceways/cve-manager/common/infrastructure/postgres"
	"github.com/opensourceways/cve-manager/cve/domain"
	"github.com/opensourceways/cve-manager/cve/domain/repository"
)

type communityPkgImpl struct {
	appPkgDB  dbimpl
	basePkgDB dbimpl
}

func NewCommunityPkg(cfg *Config) repository.CommunityPkgImpl {
	return communityPkgImpl{
		appPkgDB:  postgres.NewDBTable(cfg.Table.ApplicationPkg),
		basePkgDB: postgres.NewDBTable(cfg.Table.BasePkg),
	}
}

func (c communityPkgImpl) AddApplicationPkg(app *domain.ApplicationPackage) error {
	res := c.toApplicationPkgDO(app)

	for i := range res {
		v := &res[i]

		if err := c.appPkgDB.Insert(v); err != nil {
			return err
		}
	}

	return nil
}

func (c communityPkgImpl) AddBasePkg(app *domain.BasePackage) error {
	var do basePkgDO
	c.toBasePkgDO(app, &do)

	return c.basePkgDB.Insert(&do)
}

func (c communityPkgImpl) FindApplicationPkgs(opts repository.OptToFindPkgs) (v []domain.ApplicationPackage, err error) {
	var do []applicationPkgDO
	var filter = []postgres.ColumnFilter{
		postgres.NewEqualFilter(community, opts.Community.Community()),
	}
	if len(opts.UpdatedAt) > 0 {
		filter = append(filter, postgres.NewNotEqualFilter(updatedAt, opts.UpdatedAt))
	}

	err = c.appPkgDB.GetRecords(
		filter,
		&do,
		postgres.Pagination{
			PageNum:      opts.PageNum,
			CountPerPage: opts.CountPerPage,
		}, nil,
	)
	if err != nil {
		return
	}

	f := func(repo string) int {
		for i := range v {
			if v[i].Repository.Repo == repo {
				return i
			}
		}

		return -1
	}

	for i := range do {
		if appPkg, err := do[i].toApplicationPkg(); err != nil {
			return nil, err
		} else {
			if idx := f(appPkg.Repository.Repo); idx == -1 {
				v = append(v, appPkg)
			} else {
				v[idx].Packages = append(v[idx].Packages, appPkg.Packages...)
			}
		}
	}

	return
}

func (c communityPkgImpl) FindApplicationPkg(opts repository.OptToFindApplicationPkg) (domain.ApplicationPackage, error) {
	var do applicationPkgDO
	err := c.appPkgDB.GetRecord(
		&applicationPkgDO{PackageName: opts.Name.PackageName(), Version: opts.Version, Community: opts.Community.Community(), Repo: opts.Repo},
		&do,
	)

	if err != nil {
		return domain.ApplicationPackage{}, err
	}

	return do.toApplicationPkg()
}

func (c communityPkgImpl) FindBasePkgs(opts repository.OptToFindPkgs) (v []domain.BasePackage, err error) {
	var do []basePkgDO
	var filter = []postgres.ColumnFilter{
		postgres.NewEqualFilter(community, opts.Community.Community()),
	}

	if len(opts.UpdatedAt) > 0 {
		filter = append(filter, postgres.NewNotEqualFilter(updatedAt, opts.UpdatedAt))
	}

	err = c.basePkgDB.GetRecords(
		filter,
		&do, postgres.Pagination{
			PageNum:      opts.PageNum,
			CountPerPage: opts.CountPerPage,
		}, nil,
	)
	if err != nil {
		return
	}

	v = make([]domain.BasePackage, len(do))

	for i := range do {
		if v[i], err = do[i].toBasePkg(); err != nil {
			return
		}
	}

	return
}

func (c communityPkgImpl) FindBasePkg(opts repository.OptToFindBasePkg) (domain.BasePackage, error) {
	var do basePkgDO

	err := c.basePkgDB.GetRecord(
		&basePkgDO{Community: opts.Community.Community(), PackageName: opts.Name.PackageName()},
		&do,
	)

	if err != nil {
		return domain.BasePackage{}, err
	}

	return do.toBasePkg()
}

func (c communityPkgImpl) DeleteApplicationPkg(id string) error {
	u, err := uuid.Parse(id)
	if err != nil {
		return err
	}

	return c.appPkgDB.Delete(&applicationPkgDO{Id: u})
}

func (c communityPkgImpl) DeleteBasePkg(id string) error {
	u, err := uuid.Parse(id)
	if err != nil {
		return err
	}

	return c.appPkgDB.Delete(&basePkgDO{Id: u})
}
