package repositoryimpl

import (
	"github.com/google/uuid"

	"github.com/opensourceways/cve-manager/common/infrastructure/postgres"
	"github.com/opensourceways/cve-manager/cve/domain"
	"github.com/opensourceways/cve-manager/cve/domain/repository"
)

type applicationPkgImpl struct {
	db dbimpl
}

func NewApplicationPkg(cfg *Config) repository.ApplicationPkgRepository {
	return applicationPkgImpl{
		db: postgres.NewDBTable(cfg.Table.ApplicationPkg),
	}
}

func (a applicationPkgImpl) AddApplicationPkg(app *domain.ApplicationPackage) error {
	res := a.toApplicationPkgDO(app)

	for i := range res {
		v := &res[i]

		if err := a.db.Insert(v); err != nil {
			return err
		}
	}

	return nil
}

func (a applicationPkgImpl) FindApplicationPkgs(opts repository.OptFindApplicationPkgs) (v []domain.ApplicationPackage, err error) {
	var do []applicationPkgDO
	var filter []postgres.ColumnFilter
	if len(opts.UpdatedAt) > 0 {
		filter = append(filter, postgres.NewNotEqualFilter(updatedAt, opts.UpdatedAt))
	}

	if opts.Community != nil {
		filter = append(filter, postgres.NewEqualFilter(community, opts.Community.Community()))
	}

	err = a.db.GetRecords(
		filter,
		&do,
		postgres.Pagination{
			PageNum:      opts.PageNum,
			CountPerPage: opts.CountPerPage,
		}, nil,
	)
	if err != nil {
		return
	}

	f := func(community, repo string) int {
		for i := range v {
			r := &v[i].Repository
			if r.Repo == repo && r.Community != nil && r.Community.Community() == community {
				return i
			}
		}

		return -1
	}

	for i := range do {
		if appPkg, err := do[i].toApplicationPkg(); err != nil {
			return nil, err
		} else {
			if idx := f(appPkg.Repository.Community.Community(), appPkg.Repository.Repo); idx == -1 {
				v = append(v, appPkg)
			} else {
				v[idx].Packages = append(v[idx].Packages, appPkg.Packages...)
			}
		}
	}

	return
}

func (a applicationPkgImpl) FindApplicationPkg(opts repository.OptToFindApplicationPkg) (domain.ApplicationPackage, error) {
	var do applicationPkgDO
	err := a.db.GetRecord(
		&applicationPkgDO{PackageName: opts.Name.PackageName(), Version: opts.Version, Community: opts.Community.Community(), Repo: opts.Repo},
		&do,
	)

	if err != nil {
		return domain.ApplicationPackage{}, err
	}

	return do.toApplicationPkg()
}

func (a applicationPkgImpl) DeleteApplicationPkg(id string) error {
	u, err := uuid.Parse(id)
	if err != nil {
		return err
	}

	return a.db.Delete(&applicationPkgDO{Id: u})
}
